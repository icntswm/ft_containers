Реализуйте следующие контейнеры и включите необходимые файлы <container>.hpp:
• вектор
Вам не нужно делать специализацию vector<bool>.
• карта
• куча
Он будет использовать ваш векторный класс в качестве базового контейнера по умолчанию. Но он по-прежнему должен быть совместим с другими контейнерами, включая STL.

Вы также должны реализовать:
• iterators_traits
• реверс_итератор
• включить_если
Да, это C++11, но вы сможете реализовать его на C++98. Это задано, чтобы вы могли открыть для себя SFINAE.
• is_integral
• равные и/или лексикографические_сравнения
• станд::пара
• std::make_pair


Пространство имен должно быть ft.
• Каждая внутренняя структура данных, используемая в ваших контейнерах, должна быть логичной и обоснованной (это означает, что использование простого массива для сопоставления недопустимо).
• Вы не можете реализовать больше общедоступных функций, чем предлагается в стандартных контейнерах. Все остальное должно быть частным или защищенным. Каждая публичная функция или переменная должны быть обоснованы.
• Ожидаются все функции-члены, функции, не являющиеся членами, и перегрузки стандартных контейнеров.
• Вы должны следовать исходному именованию. Позаботьтесь о деталях.
• Если в контейнере есть система итераторов, вы должны реализовать ее.
• Вы должны использовать std::allocator.
• Для перегрузок, не являющихся членами, разрешено ключевое слово friend. Каждое использование друга должно быть обосновано и будет проверено во время оценки.
• Конечно, для реализации map::value_compare разрешено ключевое слово friend.


Вы также должны предоставить тесты, по крайней мере, main.cpp, для вашей защиты. Вы должны пойти дальше, чем главное, приведенное в качестве примера!
• Вы должны создать два двоичных файла, которые запускают одни и те же тесты: один только с вашими контейнерами, а другой с контейнерами STL.
• Сравните выходные данные и производительность/время (ваши контейнеры могут работать до 20 раз медленнее).
• Протестируйте свои контейнеры с помощью: ft::<container>